### 一. 宏观视角下的浏览器

####  01 | chrome 架构：仅仅打开了一个页面，为什么有四个进程

- 浏览器使用多进程构架的历史原因：单进程构架浏览器一旦某个 js 脚本或者插件所在的线程奔溃或者卡死会导致整个浏览器奔溃卡死，造成浏览器崩溃，卡顿，不流畅。
- 多进程构架包括一个浏览器主进程，一个网络进程，一个GPU进程，多个渲染进程，多个插件进程。一个页面拥有自己的一个渲染进程，即使当前页面渲染进程有问题或者某个插件崩溃也不会影响其他页面。

#### 02 | TCP 协议：如何保证页面文件能被完整送达浏览器

- IP : Internet Protocol 网际协议，属于网络层，表示具体计算机的网络地址，对应 IP 地址。
- UDP: User Datagram Protocol 用户数据包协议，属于传输层，指代计算机的某个应用程序，对应端口号。优点：速度快。缺点：丢包不能重传，包没有顺序，可靠性不佳。
- TCP: Transmission Control Protocol，传输控制协议，也属于传输层，与 UDP 相比有包重传机制，还提供了数据包排序功能，保证能传送完整的文件。缺点是增加了数据量，降低了传输速度。

#### 03 | HTTP 请求流程：为什么很多站点第二次打开速度会很快

![](%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0.assets/1b49976aca2c700883d48d927f48986c.png)

一图胜千言。

#### 04 | 导航流程：从输入 URL 到页面展示，这中间发生了什么

大的方面是**导航**+**渲染**

- 导航：是指开始网络请求到渲染进程开始渲染这之间的一系列过程，主要发生在网络进程中。
  1. 首先查找缓存，如果存在缓存，那么直接进入渲染进程，渲染界面。
  2.  如果没有缓存，那么网络进程开始工作，解析 DNS 生成对应的 IP 和端口号，建立 TCP 链接，进入数据传输阶段。
  3. 构建 HTTP 请求行和请求头，发起请求，等服务器响应，解析响应头信息，如果是301,302状态码，则开始重定向，从 2 重新开始导航。
  4. 读取响应内容类型，如果是浏览器能够读取的类型则会将响应体提交给渲染进程渲染，否则直接下载。
- 渲染：

#### 05 | 渲染流程（上）：HTML、CSS 和 JavaScript，是如何变成页面的

#### 04 | 渲染流程（下）：HTML、CSS 和 JavaScript，是如何变成页面的

### 二. 浏览器中的 JavaScript 执行机制

#### 07 | 变量提升：JavaScript 代码是按顺序执行的吗？

#### 08 | 调用栈：为什么 JavaScript 代码会出现栈溢出？

#### 09 | 块级作用域：var 缺陷以及为什么要引入 let 和 const？

#### 10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript 引擎是如何选择的？

#### 11 | this：从 JavaScript 执行上下文的视角讲清楚 this

js this 的出现是为了满足对象内方法对内部属性的访问，而 **this 与作用域是没有关联**的，js 作用域是词法作用域，也可以叫做静态作用域，由代码结构决定。但 **this 的指向是动态的**，**由函数的调用方式所决定**，且 **this 是与执行上下文绑定**的，一个执行上下文包含下文一个  this。

而执行上下常用的就是全局上下文和函数上下文，全局上下文下 this 默认指向 window 对象。函数上下文取决于函数调用方式，一般调用也是指向 window，严格模式下指向 undefined。当然也有一些方法可以改变函数执行上下文的 this 指向：

1. 通过辅助函数显式绑定 this，例如 Function.protoType.call， Function.protoType.apply，Function.protoType.bind 将需要绑定的 this 作为参数传给这些函数。
2. 通过对象调用，this 指向调用对象，但是如果将该对象的方法赋值给全局变量进行调用，**this 还是会指向全局对象 window**，正说明了其动态性，由函数调用方式所决定。
3. 使用 new 关键字调用构造函数，this 指向创建的对象实例。内部实现是先创建实例对象，然后通过 call 方法将函数内的 this 绑定到创建的实例对象上，然后返回该实例。

如果受到作用域分析的干扰，很容易认为 this 也有继承性，比如会认为嵌套函数中内函数的 this 会继承外函数的 this，但实际上并不会，**而只是由内函数的调用方式所决定**，所以在一些使用场景下，想在内函数访问外函数的 this 可以使用箭头函数，这是因为**箭头函数没有自己的执行上下文**，所以也就没有自己的 this 绑定，其 this 指向其所在执行上下文的 this，一般也就是其**所在的普通函数内的 this**。

